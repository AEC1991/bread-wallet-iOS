/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: BasicTypes.proto */

#ifndef PROTOBUF_C_BasicTypes_2eproto__INCLUDED
#define PROTOBUF_C_BasicTypes_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "Timestamp.pb-c.h"

typedef struct _Proto__ShardID Proto__ShardID;
typedef struct _Proto__RealmID Proto__RealmID;
typedef struct _Proto__AccountID Proto__AccountID;
typedef struct _Proto__FileID Proto__FileID;
typedef struct _Proto__ContractID Proto__ContractID;
typedef struct _Proto__TransactionID Proto__TransactionID;
typedef struct _Proto__Key Proto__Key;
typedef struct _Proto__ThresholdKey Proto__ThresholdKey;
typedef struct _Proto__KeyList Proto__KeyList;
typedef struct _Proto__Signature Proto__Signature;
typedef struct _Proto__ThresholdSignature Proto__ThresholdSignature;
typedef struct _Proto__SignatureList Proto__SignatureList;
typedef struct _Proto__SignaturePair Proto__SignaturePair;
typedef struct _Proto__SignatureMap Proto__SignatureMap;
typedef struct _Proto__FeeComponents Proto__FeeComponents;
typedef struct _Proto__TransactionFeeSchedule Proto__TransactionFeeSchedule;
typedef struct _Proto__FeeData Proto__FeeData;
typedef struct _Proto__FeeSchedule Proto__FeeSchedule;
typedef struct _Proto__CurrentAndNextFeeSchedule Proto__CurrentAndNextFeeSchedule;
typedef struct _Proto__NodeAddress Proto__NodeAddress;
typedef struct _Proto__NodeAddressBook Proto__NodeAddressBook;


/* --- enums --- */

/*
 * The functionality provided by hedera hashgraph 
 */
typedef enum _Proto__HederaFunctionality {
  /*
   * UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and not parsed (0 is ignored by parser)
   */
  PROTO__HEDERA_FUNCTIONALITY__NONE = 0,
  /*
   * crypto transfer
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoTransfer = 1,
  /*
   * crypto update account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoUpdate = 2,
  /*
   * crypto delete account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoDelete = 3,
  /*
   * crypto add claim to the account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoAddClaim = 4,
  /*
   * crypto delete claim to the account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoDeleteClaim = 5,
  /*
   * Smart Contract Call
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractCall = 6,
  /*
   * Smart Contract Create Contract
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractCreate = 7,
  /*
   * Smart Contract update contract
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractUpdate = 8,
  /*
   * File Operation create file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileCreate = 9,
  /*
   * File Operation append file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileAppend = 10,
  /*
   * File Operation update file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileUpdate = 11,
  /*
   * File Operation delete file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileDelete = 12,
  /*
   * crypto get account balance
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetAccountBalance = 13,
  /*
   * crypto get account record
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetAccountRecords = 14,
  /*
   * Crypto get info
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetInfo = 15,
  /*
   * Smart Contract Call
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractCallLocal = 16,
  /*
   * Smart Contract get info
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractGetInfo = 17,
  /*
   * Smart Contract, get the byte code
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractGetBytecode = 18,
  /*
   * Smart Contract, get by solidity ID
   */
  PROTO__HEDERA_FUNCTIONALITY__GetBySolidityID = 19,
  /*
   * Smart Contract, get by key
   */
  PROTO__HEDERA_FUNCTIONALITY__GetByKey = 20,
  /*
   * Crypto get the claim
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetClaim = 21,
  /*
   * Crypto, get the stakers for the node
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoGetStakers = 22,
  /*
   * File Operations get file contents
   */
  PROTO__HEDERA_FUNCTIONALITY__FileGetContents = 23,
  /*
   * File Operations get the info of the file
   */
  PROTO__HEDERA_FUNCTIONALITY__FileGetInfo = 24,
  /*
   * Crypto get the transaction records
   */
  PROTO__HEDERA_FUNCTIONALITY__TransactionGetRecord = 25,
  /*
   * Contract get the transaction records
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractGetRecords = 26,
  /*
   * crypto create account
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoCreate = 27,
  /*
   * system delete file
   */
  PROTO__HEDERA_FUNCTIONALITY__SystemDelete = 28,
  /*
   * system undelete file
   */
  PROTO__HEDERA_FUNCTIONALITY__SystemUndelete = 29,
  /*
   * delete contract
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractDelete = 30,
  /*
   * freeze
   */
  PROTO__HEDERA_FUNCTIONALITY__Freeze = 31,
  /*
   * Create Tx Record
   */
  PROTO__HEDERA_FUNCTIONALITY__CreateTransactionRecord = 32,
  /*
   * Crypto Auto Renew
   */
  PROTO__HEDERA_FUNCTIONALITY__CryptoAccountAutoRenew = 33,
  /*
   * Contract Auto Renew
   */
  PROTO__HEDERA_FUNCTIONALITY__ContractAutoRenew = 34,
  /*
   *Get Version
   */
  PROTO__HEDERA_FUNCTIONALITY__getVersion = 35,
  /*
   * Transaction Get Receipt
   */
  PROTO__HEDERA_FUNCTIONALITY__TransactionGetReceipt = 36
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__HEDERA_FUNCTIONALITY)
} Proto__HederaFunctionality;

/* --- messages --- */

/*
 * Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
 *Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial. 
 */
struct  _Proto__ShardID
{
  ProtobufCMessage base;
  /*
   *the shard number (nonnegative)
   */
  int64_t shardnum;
};
#define PROTO__SHARD_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__shard_id__descriptor) \
    , 0 }


/*
 * The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm. 
 */
struct  _Proto__RealmID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
};
#define PROTO__REALM_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__realm_id__descriptor) \
    , 0, 0 }


/*
 * The ID for an a cryptocurrency account  
 */
struct  _Proto__AccountID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   *A nonnegative account number unique within its realm
   */
  int64_t accountnum;
};
#define PROTO__ACCOUNT_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__account_id__descriptor) \
    , 0, 0, 0 }


/*
 * The ID for a file  
 */
struct  _Proto__FileID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   *A nonnegative File number unique within its realm
   */
  int64_t filenum;
};
#define PROTO__FILE_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__file_id__descriptor) \
    , 0, 0, 0 }


/*
 * The ID for a smart contract instance  
 */
struct  _Proto__ContractID
{
  ProtobufCMessage base;
  /*
   *The shard number (nonnegative)
   */
  int64_t shardnum;
  /*
   *The realm number (nonnegative)
   */
  int64_t realmnum;
  /*
   *A nonnegative number unique within its realm
   */
  int64_t contractnum;
};
#define PROTO__CONTRACT_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__contract_id__descriptor) \
    , 0, 0, 0 }


/*
 * The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes. 
 */
struct  _Proto__TransactionID
{
  ProtobufCMessage base;
  /*
   * The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
   */
  Proto__Timestamp *transactionvalidstart;
  /*
   *The Account ID that paid for this transaction
   */
  Proto__AccountID *accountid;
};
#define PROTO__TRANSACTION_ID__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__transaction_id__descriptor) \
    , NULL, NULL }


typedef enum {
  PROTO__KEY__KEY__NOT_SET = 0,
  PROTO__KEY__KEY_CONTRACT_ID = 1,
  PROTO__KEY__KEY_ED25519 = 2,
  PROTO__KEY__KEY_RSA_3072 = 3,
  PROTO__KEY__KEY_ECDSA_384 = 4,
  PROTO__KEY__KEY_THRESHOLD_KEY = 5,
  PROTO__KEY__KEY_KEY_LIST = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__KEY__KEY)
} Proto__Key__KeyCase;

/*
 * A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
 * A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
 * A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
 * A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.
 * A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive keys (e.g., ed25519) has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive keys (e.g., ed25519) has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
 * Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
 */
struct  _Proto__Key
{
  ProtobufCMessage base;
  Proto__Key__KeyCase key_case;
  union {
    /*
     * smart contract instance that is authorized as if it had signed with a key
     */
    Proto__ContractID *contractid;
    /*
     * ed25519 public key bytes
     */
    ProtobufCBinaryData ed25519;
    /*
     *RSA-3072 public key bytes
     */
    ProtobufCBinaryData rsa_3072;
    /*
     *ECDSA with the p-384 curve public key bytes
     */
    ProtobufCBinaryData ecdsa_384;
    /*
     * a threshold N followed by a list of M keys, any N of which are required to form a valid signature
     */
    Proto__ThresholdKey *thresholdkey;
    /*
     * A list of Keys of the Key type.
     */
    Proto__KeyList *keylist;
  };
};
#define PROTO__KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__key__descriptor) \
    , PROTO__KEY__KEY__NOT_SET, {0} }


/*
 * A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here. 
 */
struct  _Proto__ThresholdKey
{
  ProtobufCMessage base;
  /*
   * A valid signature set must have at least this many signatures
   */
  uint32_t threshold;
  /*
   * List of all the keys that can sign
   */
  Proto__KeyList *keys;
};
#define PROTO__THRESHOLD_KEY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__threshold_key__descriptor) \
    , 0, NULL }


/*
 * A list of keys 
 */
struct  _Proto__KeyList
{
  ProtobufCMessage base;
  /*
   * list of keys
   */
  size_t n_keys;
  Proto__Key **keys;
};
#define PROTO__KEY_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__key_list__descriptor) \
    , 0,NULL }


typedef enum {
  PROTO__SIGNATURE__SIGNATURE__NOT_SET = 0,
  PROTO__SIGNATURE__SIGNATURE_CONTRACT = 1,
  PROTO__SIGNATURE__SIGNATURE_ED25519 = 2,
  PROTO__SIGNATURE__SIGNATURE_RSA_3072 = 3,
  PROTO__SIGNATURE__SIGNATURE_ECDSA_384 = 4,
  PROTO__SIGNATURE__SIGNATURE_THRESHOLD_SIGNATURE = 5,
  PROTO__SIGNATURE__SIGNATURE_SIGNATURE_LIST = 6
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__SIGNATURE__SIGNATURE)
} Proto__Signature__SignatureCase;

/*
 * A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
 * The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
 * This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
 */
struct  _Proto__Signature
{
  ProtobufCMessage base;
  Proto__Signature__SignatureCase signature_case;
  union {
    /*
     * smart contract virtual signature (always length zero)
     */
    ProtobufCBinaryData contract;
    /*
     * ed25519 signature bytes
     */
    ProtobufCBinaryData ed25519;
    /*
     *RSA-3072 signature bytes
     */
    ProtobufCBinaryData rsa_3072;
    /*
     *ECDSA p-384 signature bytes
     */
    ProtobufCBinaryData ecdsa_384;
    /*
     * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M signatures, at least N of which are non-null.
     */
    Proto__ThresholdSignature *thresholdsignature;
    /*
     * A list of M signatures, each corresponding to a Key in a KeyList of the same length.
     */
    Proto__SignatureList *signaturelist;
  };
};
#define PROTO__SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature__descriptor) \
    , PROTO__SIGNATURE__SIGNATURE__NOT_SET, {0} }


/*
 * A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null. 
 * This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
 */
struct  _Proto__ThresholdSignature
{
  ProtobufCMessage base;
  /*
   * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null
   */
  Proto__SignatureList *sigs;
};
#define PROTO__THRESHOLD_SIGNATURE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__threshold_signature__descriptor) \
    , NULL }


/*
 * The signatures corresponding to a KeyList of the same length.
 * This message is deprecated and succeeded by SignaturePair and SignatureMap messages. 
 */
struct  _Proto__SignatureList
{
  ProtobufCMessage base;
  /*
   * each signature corresponds to a Key in the KeyList
   */
  size_t n_sigs;
  Proto__Signature **sigs;
};
#define PROTO__SIGNATURE_LIST__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature_list__descriptor) \
    , 0,NULL }


typedef enum {
  PROTO__SIGNATURE_PAIR__SIGNATURE__NOT_SET = 0,
  PROTO__SIGNATURE_PAIR__SIGNATURE_CONTRACT = 2,
  PROTO__SIGNATURE_PAIR__SIGNATURE_ED25519 = 3,
  PROTO__SIGNATURE_PAIR__SIGNATURE_RSA_3072 = 4,
  PROTO__SIGNATURE_PAIR__SIGNATURE_ECDSA_384 = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTO__SIGNATURE_PAIR__SIGNATURE)
} Proto__SignaturePair__SignatureCase;

/*
 * The client may use any number of bytes from 0 to the whole length of the public key for pubKeyPrefix. 
 * If 0 bytes is used, then it is assumed that only one public key is used to sign.
 */
struct  _Proto__SignaturePair
{
  ProtobufCMessage base;
  /*
   * First few bytes of the public key
   */
  ProtobufCBinaryData pubkeyprefix;
  Proto__SignaturePair__SignatureCase signature_case;
  union {
    /*
     * smart contract virtual signature (always length zero)
     */
    ProtobufCBinaryData contract;
    /*
     * ed25519 signature
     */
    ProtobufCBinaryData ed25519;
    /*
     *RSA-3072 signature
     */
    ProtobufCBinaryData rsa_3072;
    /*
     *ECDSA p-384 signature
     */
    ProtobufCBinaryData ecdsa_384;
  };
};
#define PROTO__SIGNATURE_PAIR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature_pair__descriptor) \
    , {0,NULL}, PROTO__SIGNATURE_PAIR__SIGNATURE__NOT_SET, {0} }


/*
 * A set of signatures corresponding to every unique public key used to sign a given transaction. 
 * If one public key matches more than one prefixes on the signature map, the transaction containing the map will fail immediately with the response code KEY_PREFIX_MISMATCH.  
 */
struct  _Proto__SignatureMap
{
  ProtobufCMessage base;
  /*
   * Each signature pair corresponds to a unique Key required to sign the transaction.
   */
  size_t n_sigpair;
  Proto__SignaturePair **sigpair;
};
#define PROTO__SIGNATURE_MAP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__signature_map__descriptor) \
    , 0,NULL }


struct  _Proto__FeeComponents
{
  ProtobufCMessage base;
  /*
   * The minimum fees that needs to be paid
   */
  int64_t min;
  /*
   * The maximum fees that can be submitted
   */
  int64_t max;
  /*
   * A constant determined by the business to calculate the fees
   */
  int64_t constant;
  /*
   * Bytes per transaction
   */
  int64_t bpt;
  /*
   * Verifications per transaction
   */
  int64_t vpt;
  /*
   * Ram byte seconds
   */
  int64_t rbh;
  /*
   * Storage byte seconds
   */
  int64_t sbh;
  /*
   * Gas for the contract execution
   */
  int64_t gas;
  /*
   * Transaction value (crypto transfers amount, tv is in tiny bars divided by 1000, rounded down)
   */
  int64_t tv;
  /*
   * Bytes per response
   */
  int64_t bpr;
  /*
   * Storage bytes per response
   */
  int64_t sbpr;
};
#define PROTO__FEE_COMPONENTS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fee_components__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


/*
 * The fees for a specific transaction or query based on the fee data. 
 */
struct  _Proto__TransactionFeeSchedule
{
  ProtobufCMessage base;
  /*
   * Specific Transaction or Query
   */
  Proto__HederaFunctionality hederafunctionality;
  /*
   * The fee information about the query/data
   */
  Proto__FeeData *feedata;
};
#define PROTO__TRANSACTION_FEE_SCHEDULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__transaction_fee_schedule__descriptor) \
    , PROTO__HEDERA_FUNCTIONALITY__NONE, NULL }


/*
 * The total fees charged for a transaction. It contains three parts namely node data, network data and service data 
 */
struct  _Proto__FeeData
{
  ProtobufCMessage base;
  /*
   * Fee charged by Node for this functionality
   */
  Proto__FeeComponents *nodedata;
  /*
   * Fee charged for network operations by Hedera
   */
  Proto__FeeComponents *networkdata;
  /*
   * Fee charged for providing service by Hedera
   */
  Proto__FeeComponents *servicedata;
};
#define PROTO__FEE_DATA__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fee_data__descriptor) \
    , NULL, NULL, NULL }


/*
 * The fee schedule for a specific hedera functionality and the time period this fee schedule will expire  
 */
struct  _Proto__FeeSchedule
{
  ProtobufCMessage base;
  /*
   * Contains multiple functionality specific fee schedule.
   */
  size_t n_transactionfeeschedule;
  Proto__TransactionFeeSchedule **transactionfeeschedule;
  /*
   * FeeSchedule expiry time
   */
  Proto__TimestampSeconds *expirytime;
};
#define PROTO__FEE_SCHEDULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__fee_schedule__descriptor) \
    , 0,NULL, NULL }


/*
 * This contains two Fee Schedules with expiry timestamp. 
 */
struct  _Proto__CurrentAndNextFeeSchedule
{
  ProtobufCMessage base;
  /*
   * Contains current Fee Schedule
   */
  Proto__FeeSchedule *currentfeeschedule;
  /*
   * Contains next Fee Schedule
   */
  Proto__FeeSchedule *nextfeeschedule;
};
#define PROTO__CURRENT_AND_NEXT_FEE_SCHEDULE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__current_and_next_fee_schedule__descriptor) \
    , NULL, NULL }


/*
 * The information about a node 
 */
struct  _Proto__NodeAddress
{
  ProtobufCMessage base;
  /*
   * The ip address of the Node with separator & octets
   */
  ProtobufCBinaryData ipaddress;
  /*
   * The port number of the grpc server for the node
   */
  int32_t portno;
  /*
   * The memo field of the node
   */
  ProtobufCBinaryData memo;
  /*
   * The RSA public key of the node.
   */
  char *rsa_pubkey;
};
#define PROTO__NODE_ADDRESS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__node_address__descriptor) \
    , {0,NULL}, 0, {0,NULL}, (char *)protobuf_c_empty_string }


/*
 * Gives the node addresses in the address book 
 */
struct  _Proto__NodeAddressBook
{
  ProtobufCMessage base;
  /*
   * Contains multiple Node Address for the network
   */
  size_t n_nodeaddress;
  Proto__NodeAddress **nodeaddress;
};
#define PROTO__NODE_ADDRESS_BOOK__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__node_address_book__descriptor) \
    , 0,NULL }


/* Proto__ShardID methods */
void   proto__shard_id__init
                     (Proto__ShardID         *message);
size_t proto__shard_id__get_packed_size
                     (const Proto__ShardID   *message);
size_t proto__shard_id__pack
                     (const Proto__ShardID   *message,
                      uint8_t             *out);
size_t proto__shard_id__pack_to_buffer
                     (const Proto__ShardID   *message,
                      ProtobufCBuffer     *buffer);
Proto__ShardID *
       proto__shard_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__shard_id__free_unpacked
                     (Proto__ShardID *message,
                      ProtobufCAllocator *allocator);
/* Proto__RealmID methods */
void   proto__realm_id__init
                     (Proto__RealmID         *message);
size_t proto__realm_id__get_packed_size
                     (const Proto__RealmID   *message);
size_t proto__realm_id__pack
                     (const Proto__RealmID   *message,
                      uint8_t             *out);
size_t proto__realm_id__pack_to_buffer
                     (const Proto__RealmID   *message,
                      ProtobufCBuffer     *buffer);
Proto__RealmID *
       proto__realm_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__realm_id__free_unpacked
                     (Proto__RealmID *message,
                      ProtobufCAllocator *allocator);
/* Proto__AccountID methods */
void   proto__account_id__init
                     (Proto__AccountID         *message);
size_t proto__account_id__get_packed_size
                     (const Proto__AccountID   *message);
size_t proto__account_id__pack
                     (const Proto__AccountID   *message,
                      uint8_t             *out);
size_t proto__account_id__pack_to_buffer
                     (const Proto__AccountID   *message,
                      ProtobufCBuffer     *buffer);
Proto__AccountID *
       proto__account_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__account_id__free_unpacked
                     (Proto__AccountID *message,
                      ProtobufCAllocator *allocator);
/* Proto__FileID methods */
void   proto__file_id__init
                     (Proto__FileID         *message);
size_t proto__file_id__get_packed_size
                     (const Proto__FileID   *message);
size_t proto__file_id__pack
                     (const Proto__FileID   *message,
                      uint8_t             *out);
size_t proto__file_id__pack_to_buffer
                     (const Proto__FileID   *message,
                      ProtobufCBuffer     *buffer);
Proto__FileID *
       proto__file_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__file_id__free_unpacked
                     (Proto__FileID *message,
                      ProtobufCAllocator *allocator);
/* Proto__ContractID methods */
void   proto__contract_id__init
                     (Proto__ContractID         *message);
size_t proto__contract_id__get_packed_size
                     (const Proto__ContractID   *message);
size_t proto__contract_id__pack
                     (const Proto__ContractID   *message,
                      uint8_t             *out);
size_t proto__contract_id__pack_to_buffer
                     (const Proto__ContractID   *message,
                      ProtobufCBuffer     *buffer);
Proto__ContractID *
       proto__contract_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__contract_id__free_unpacked
                     (Proto__ContractID *message,
                      ProtobufCAllocator *allocator);
/* Proto__TransactionID methods */
void   proto__transaction_id__init
                     (Proto__TransactionID         *message);
size_t proto__transaction_id__get_packed_size
                     (const Proto__TransactionID   *message);
size_t proto__transaction_id__pack
                     (const Proto__TransactionID   *message,
                      uint8_t             *out);
size_t proto__transaction_id__pack_to_buffer
                     (const Proto__TransactionID   *message,
                      ProtobufCBuffer     *buffer);
Proto__TransactionID *
       proto__transaction_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__transaction_id__free_unpacked
                     (Proto__TransactionID *message,
                      ProtobufCAllocator *allocator);
/* Proto__Key methods */
void   proto__key__init
                     (Proto__Key         *message);
size_t proto__key__get_packed_size
                     (const Proto__Key   *message);
size_t proto__key__pack
                     (const Proto__Key   *message,
                      uint8_t             *out);
size_t proto__key__pack_to_buffer
                     (const Proto__Key   *message,
                      ProtobufCBuffer     *buffer);
Proto__Key *
       proto__key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__key__free_unpacked
                     (Proto__Key *message,
                      ProtobufCAllocator *allocator);
/* Proto__ThresholdKey methods */
void   proto__threshold_key__init
                     (Proto__ThresholdKey         *message);
size_t proto__threshold_key__get_packed_size
                     (const Proto__ThresholdKey   *message);
size_t proto__threshold_key__pack
                     (const Proto__ThresholdKey   *message,
                      uint8_t             *out);
size_t proto__threshold_key__pack_to_buffer
                     (const Proto__ThresholdKey   *message,
                      ProtobufCBuffer     *buffer);
Proto__ThresholdKey *
       proto__threshold_key__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__threshold_key__free_unpacked
                     (Proto__ThresholdKey *message,
                      ProtobufCAllocator *allocator);
/* Proto__KeyList methods */
void   proto__key_list__init
                     (Proto__KeyList         *message);
size_t proto__key_list__get_packed_size
                     (const Proto__KeyList   *message);
size_t proto__key_list__pack
                     (const Proto__KeyList   *message,
                      uint8_t             *out);
size_t proto__key_list__pack_to_buffer
                     (const Proto__KeyList   *message,
                      ProtobufCBuffer     *buffer);
Proto__KeyList *
       proto__key_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__key_list__free_unpacked
                     (Proto__KeyList *message,
                      ProtobufCAllocator *allocator);
/* Proto__Signature methods */
void   proto__signature__init
                     (Proto__Signature         *message);
size_t proto__signature__get_packed_size
                     (const Proto__Signature   *message);
size_t proto__signature__pack
                     (const Proto__Signature   *message,
                      uint8_t             *out);
size_t proto__signature__pack_to_buffer
                     (const Proto__Signature   *message,
                      ProtobufCBuffer     *buffer);
Proto__Signature *
       proto__signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature__free_unpacked
                     (Proto__Signature *message,
                      ProtobufCAllocator *allocator);
/* Proto__ThresholdSignature methods */
void   proto__threshold_signature__init
                     (Proto__ThresholdSignature         *message);
size_t proto__threshold_signature__get_packed_size
                     (const Proto__ThresholdSignature   *message);
size_t proto__threshold_signature__pack
                     (const Proto__ThresholdSignature   *message,
                      uint8_t             *out);
size_t proto__threshold_signature__pack_to_buffer
                     (const Proto__ThresholdSignature   *message,
                      ProtobufCBuffer     *buffer);
Proto__ThresholdSignature *
       proto__threshold_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__threshold_signature__free_unpacked
                     (Proto__ThresholdSignature *message,
                      ProtobufCAllocator *allocator);
/* Proto__SignatureList methods */
void   proto__signature_list__init
                     (Proto__SignatureList         *message);
size_t proto__signature_list__get_packed_size
                     (const Proto__SignatureList   *message);
size_t proto__signature_list__pack
                     (const Proto__SignatureList   *message,
                      uint8_t             *out);
size_t proto__signature_list__pack_to_buffer
                     (const Proto__SignatureList   *message,
                      ProtobufCBuffer     *buffer);
Proto__SignatureList *
       proto__signature_list__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature_list__free_unpacked
                     (Proto__SignatureList *message,
                      ProtobufCAllocator *allocator);
/* Proto__SignaturePair methods */
void   proto__signature_pair__init
                     (Proto__SignaturePair         *message);
size_t proto__signature_pair__get_packed_size
                     (const Proto__SignaturePair   *message);
size_t proto__signature_pair__pack
                     (const Proto__SignaturePair   *message,
                      uint8_t             *out);
size_t proto__signature_pair__pack_to_buffer
                     (const Proto__SignaturePair   *message,
                      ProtobufCBuffer     *buffer);
Proto__SignaturePair *
       proto__signature_pair__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature_pair__free_unpacked
                     (Proto__SignaturePair *message,
                      ProtobufCAllocator *allocator);
/* Proto__SignatureMap methods */
void   proto__signature_map__init
                     (Proto__SignatureMap         *message);
size_t proto__signature_map__get_packed_size
                     (const Proto__SignatureMap   *message);
size_t proto__signature_map__pack
                     (const Proto__SignatureMap   *message,
                      uint8_t             *out);
size_t proto__signature_map__pack_to_buffer
                     (const Proto__SignatureMap   *message,
                      ProtobufCBuffer     *buffer);
Proto__SignatureMap *
       proto__signature_map__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__signature_map__free_unpacked
                     (Proto__SignatureMap *message,
                      ProtobufCAllocator *allocator);
/* Proto__FeeComponents methods */
void   proto__fee_components__init
                     (Proto__FeeComponents         *message);
size_t proto__fee_components__get_packed_size
                     (const Proto__FeeComponents   *message);
size_t proto__fee_components__pack
                     (const Proto__FeeComponents   *message,
                      uint8_t             *out);
size_t proto__fee_components__pack_to_buffer
                     (const Proto__FeeComponents   *message,
                      ProtobufCBuffer     *buffer);
Proto__FeeComponents *
       proto__fee_components__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fee_components__free_unpacked
                     (Proto__FeeComponents *message,
                      ProtobufCAllocator *allocator);
/* Proto__TransactionFeeSchedule methods */
void   proto__transaction_fee_schedule__init
                     (Proto__TransactionFeeSchedule         *message);
size_t proto__transaction_fee_schedule__get_packed_size
                     (const Proto__TransactionFeeSchedule   *message);
size_t proto__transaction_fee_schedule__pack
                     (const Proto__TransactionFeeSchedule   *message,
                      uint8_t             *out);
size_t proto__transaction_fee_schedule__pack_to_buffer
                     (const Proto__TransactionFeeSchedule   *message,
                      ProtobufCBuffer     *buffer);
Proto__TransactionFeeSchedule *
       proto__transaction_fee_schedule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__transaction_fee_schedule__free_unpacked
                     (Proto__TransactionFeeSchedule *message,
                      ProtobufCAllocator *allocator);
/* Proto__FeeData methods */
void   proto__fee_data__init
                     (Proto__FeeData         *message);
size_t proto__fee_data__get_packed_size
                     (const Proto__FeeData   *message);
size_t proto__fee_data__pack
                     (const Proto__FeeData   *message,
                      uint8_t             *out);
size_t proto__fee_data__pack_to_buffer
                     (const Proto__FeeData   *message,
                      ProtobufCBuffer     *buffer);
Proto__FeeData *
       proto__fee_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fee_data__free_unpacked
                     (Proto__FeeData *message,
                      ProtobufCAllocator *allocator);
/* Proto__FeeSchedule methods */
void   proto__fee_schedule__init
                     (Proto__FeeSchedule         *message);
size_t proto__fee_schedule__get_packed_size
                     (const Proto__FeeSchedule   *message);
size_t proto__fee_schedule__pack
                     (const Proto__FeeSchedule   *message,
                      uint8_t             *out);
size_t proto__fee_schedule__pack_to_buffer
                     (const Proto__FeeSchedule   *message,
                      ProtobufCBuffer     *buffer);
Proto__FeeSchedule *
       proto__fee_schedule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__fee_schedule__free_unpacked
                     (Proto__FeeSchedule *message,
                      ProtobufCAllocator *allocator);
/* Proto__CurrentAndNextFeeSchedule methods */
void   proto__current_and_next_fee_schedule__init
                     (Proto__CurrentAndNextFeeSchedule         *message);
size_t proto__current_and_next_fee_schedule__get_packed_size
                     (const Proto__CurrentAndNextFeeSchedule   *message);
size_t proto__current_and_next_fee_schedule__pack
                     (const Proto__CurrentAndNextFeeSchedule   *message,
                      uint8_t             *out);
size_t proto__current_and_next_fee_schedule__pack_to_buffer
                     (const Proto__CurrentAndNextFeeSchedule   *message,
                      ProtobufCBuffer     *buffer);
Proto__CurrentAndNextFeeSchedule *
       proto__current_and_next_fee_schedule__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__current_and_next_fee_schedule__free_unpacked
                     (Proto__CurrentAndNextFeeSchedule *message,
                      ProtobufCAllocator *allocator);
/* Proto__NodeAddress methods */
void   proto__node_address__init
                     (Proto__NodeAddress         *message);
size_t proto__node_address__get_packed_size
                     (const Proto__NodeAddress   *message);
size_t proto__node_address__pack
                     (const Proto__NodeAddress   *message,
                      uint8_t             *out);
size_t proto__node_address__pack_to_buffer
                     (const Proto__NodeAddress   *message,
                      ProtobufCBuffer     *buffer);
Proto__NodeAddress *
       proto__node_address__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__node_address__free_unpacked
                     (Proto__NodeAddress *message,
                      ProtobufCAllocator *allocator);
/* Proto__NodeAddressBook methods */
void   proto__node_address_book__init
                     (Proto__NodeAddressBook         *message);
size_t proto__node_address_book__get_packed_size
                     (const Proto__NodeAddressBook   *message);
size_t proto__node_address_book__pack
                     (const Proto__NodeAddressBook   *message,
                      uint8_t             *out);
size_t proto__node_address_book__pack_to_buffer
                     (const Proto__NodeAddressBook   *message,
                      ProtobufCBuffer     *buffer);
Proto__NodeAddressBook *
       proto__node_address_book__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__node_address_book__free_unpacked
                     (Proto__NodeAddressBook *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__ShardID_Closure)
                 (const Proto__ShardID *message,
                  void *closure_data);
typedef void (*Proto__RealmID_Closure)
                 (const Proto__RealmID *message,
                  void *closure_data);
typedef void (*Proto__AccountID_Closure)
                 (const Proto__AccountID *message,
                  void *closure_data);
typedef void (*Proto__FileID_Closure)
                 (const Proto__FileID *message,
                  void *closure_data);
typedef void (*Proto__ContractID_Closure)
                 (const Proto__ContractID *message,
                  void *closure_data);
typedef void (*Proto__TransactionID_Closure)
                 (const Proto__TransactionID *message,
                  void *closure_data);
typedef void (*Proto__Key_Closure)
                 (const Proto__Key *message,
                  void *closure_data);
typedef void (*Proto__ThresholdKey_Closure)
                 (const Proto__ThresholdKey *message,
                  void *closure_data);
typedef void (*Proto__KeyList_Closure)
                 (const Proto__KeyList *message,
                  void *closure_data);
typedef void (*Proto__Signature_Closure)
                 (const Proto__Signature *message,
                  void *closure_data);
typedef void (*Proto__ThresholdSignature_Closure)
                 (const Proto__ThresholdSignature *message,
                  void *closure_data);
typedef void (*Proto__SignatureList_Closure)
                 (const Proto__SignatureList *message,
                  void *closure_data);
typedef void (*Proto__SignaturePair_Closure)
                 (const Proto__SignaturePair *message,
                  void *closure_data);
typedef void (*Proto__SignatureMap_Closure)
                 (const Proto__SignatureMap *message,
                  void *closure_data);
typedef void (*Proto__FeeComponents_Closure)
                 (const Proto__FeeComponents *message,
                  void *closure_data);
typedef void (*Proto__TransactionFeeSchedule_Closure)
                 (const Proto__TransactionFeeSchedule *message,
                  void *closure_data);
typedef void (*Proto__FeeData_Closure)
                 (const Proto__FeeData *message,
                  void *closure_data);
typedef void (*Proto__FeeSchedule_Closure)
                 (const Proto__FeeSchedule *message,
                  void *closure_data);
typedef void (*Proto__CurrentAndNextFeeSchedule_Closure)
                 (const Proto__CurrentAndNextFeeSchedule *message,
                  void *closure_data);
typedef void (*Proto__NodeAddress_Closure)
                 (const Proto__NodeAddress *message,
                  void *closure_data);
typedef void (*Proto__NodeAddressBook_Closure)
                 (const Proto__NodeAddressBook *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    proto__hedera_functionality__descriptor;
extern const ProtobufCMessageDescriptor proto__shard_id__descriptor;
extern const ProtobufCMessageDescriptor proto__realm_id__descriptor;
extern const ProtobufCMessageDescriptor proto__account_id__descriptor;
extern const ProtobufCMessageDescriptor proto__file_id__descriptor;
extern const ProtobufCMessageDescriptor proto__contract_id__descriptor;
extern const ProtobufCMessageDescriptor proto__transaction_id__descriptor;
extern const ProtobufCMessageDescriptor proto__key__descriptor;
extern const ProtobufCMessageDescriptor proto__threshold_key__descriptor;
extern const ProtobufCMessageDescriptor proto__key_list__descriptor;
extern const ProtobufCMessageDescriptor proto__signature__descriptor;
extern const ProtobufCMessageDescriptor proto__threshold_signature__descriptor;
extern const ProtobufCMessageDescriptor proto__signature_list__descriptor;
extern const ProtobufCMessageDescriptor proto__signature_pair__descriptor;
extern const ProtobufCMessageDescriptor proto__signature_map__descriptor;
extern const ProtobufCMessageDescriptor proto__fee_components__descriptor;
extern const ProtobufCMessageDescriptor proto__transaction_fee_schedule__descriptor;
extern const ProtobufCMessageDescriptor proto__fee_data__descriptor;
extern const ProtobufCMessageDescriptor proto__fee_schedule__descriptor;
extern const ProtobufCMessageDescriptor proto__current_and_next_fee_schedule__descriptor;
extern const ProtobufCMessageDescriptor proto__node_address__descriptor;
extern const ProtobufCMessageDescriptor proto__node_address_book__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_BasicTypes_2eproto__INCLUDED */
